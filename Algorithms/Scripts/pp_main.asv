%% TRAJECTORY COMPUTATION

close all
global nRobots samplingTime pathColors maxVelocity maxAcceleration;
global maxGen popSize crossoverFraction mutationRate bestFitHistory executionTime;
global StepSizeHistory

addpath("Interpolators"); % Contains MEX-files to speed up execution

openfig("warehouse.fig");
paths = {};
paths = load("C:\Users\Luca\Desktop\Collaborative path\paths_registration.mat").paths_registration;

nRobots = size(paths,2);

for j=1:nRobots
    paths{j} = unique(paths{j},'rows','stable');
end

%% VARIABLES
robotSize = 1;
delta_s = 2;
collisionThreshold = delta_s;
maxVelocity = 1.5;
maxAcceleration = 1;

%% OPTIONS
animation = false;
animVelocity = 7;
recordAnimation = true;
solveCollisions = true;
preloadOptimization = false;
plotVelocities = false;
plotCollisions = false;

% Warning: Only activate if they are the only plot
plotRobotsClosestObstacles = false;

samplingTime = 0.1;

% Create random path colors
pathColors = distinguishable_colors(nRobots);


%% INTERPOLATION
trajectories = {};
for j=1:nRobots
    trajectories{j} = pp_interpolatePath2(paths{j},0,0);
end

pp_plotRobotsClosestObstacles(trajectories,delta_s,'-',"Before optimization",plotRobotsClosestObstacles);


%% COLLISION CHECKING
collisions = {};
for j=1:nRobots
    collisions{j} = pp_checkCollisionForOneRobot(paths,trajectories,collisionThreshold,j);
end


if plotCollisions
    pp_plotCollisions(collisions,trajectories);
end

finishTimes = [];
for j=1:nRobots
    finishTimes = [finishTimes, trajectories{j}.t_tot(end)];
end
finishTimes


%% COLLISIONS
tic
if ~all(cellfun(@isempty,collisions)) && solveCollisions
     
    global x_opt;

    if preloadOptimization==false
        global maxGen popSize bestFitHistory executionTime;
    
        % Set ub and lb
        lb = [];
        ub = [];
    
        for i = 1:nRobots
            % Lower bounds for d_i, L_s, and alpha
            lb = [lb, 0, 0, 0.1];
    
            % Calculate the upper bound for L_s based on segments
            max_Ls = norm(paths{i}(2,:) - paths{i}(1,:)); % Length of the first segment
    
            % Upper bounds for d_i (binary), L_s (max segment length), and alpha
            ub = [ub, 1, max_Ls, 1];
        end
    
        % Set the integer constraints for d_i
        intcon = 1:3:(3*nRobots); % Indices for d_i
    
        % Set optimization options
        % Set the options for the genetic algorithm
        options_ga = optimoptions('ga', ...
        'Display', 'iter', ...
        'MaxGenerations', maxGen, ...
        'PopulationSize', popSize, ...
        'PlotFcn', [],...
        'CrossoverFraction', crossoverFraction, ...
        'MutationFcn', {@mutationuniform, mutationRate}, ...
        'MaxStallGenerations', maxGen, ...
        'OutputFcn', @o_saveBestFit);
    
        % Call the ga solver
    
        objectiveFun = @(x) o_objective(x,paths);
        constraintFun = @(x) o_collision_constraint(x,paths,delta_s);
    
        [x_opt, fval] = ga(objectiveFun, 3*nRobots, [], [], [], [], lb, ub, constraintFun, intcon, options_ga);
        
        save("x_opt.mat","x_opt");
    else
        x_opt = load("x_opt.mat").x_opt;
    end

    % bestFitHistory = load("bestFitHistory.mat").bestFitHistory;

    % Add the optimized segments
    for j=1:nRobots

        newSegment = 1;
        d_j = x_opt(3*(j-1) + 1);
        L_s_j = x_opt(3*(j-1) + 2);
        alpha_j = x_opt(3*(j-1) + 3);

        if d_j==1
            paths{j} = pp_addNewSegment(paths{j},newSegment,0,L_s_j);
            trajectories{j} = pp_interpolatePath2(paths{j},newSegment,alpha_j);
        end

    end
end
executionTime = toc;


pp_plotPathOnMap(paths,trajectories,'-');

if plotVelocities
    % Plot positions, velocities and accelerations
    pp_producePlots(trajectories,delta_s,plotVelocities);
end

% figure;
% plot(1:length(bestFitHistory),bestFitHistory,'LineWidth',1.8);
% xlabel('Generation');
% ylabel('Best Fitness Value');
% title('Best Fitness Value Over Generations');
% grid on;


%% ANIMATION
if animation
    fprintf("\nPress enter to record animation with velocity %dx...\n",animVelocity);
    pp_animateTrajectory(trajectories,robotSize,recordAnimation,animVelocity);
end

pp_plotRobotsClosestObstacles(trajectories,delta_s,'--',"After optimization",plotRobotsClosestObstacles);

total_energy_consumption = pp_computeEnergy(trajectories)

% figure(1)
% saveas(gcf,'warehouse.png')




